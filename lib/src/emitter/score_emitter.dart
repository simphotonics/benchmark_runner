// ignore_for_file: prefer_interpolation_to_compose_strings
import 'package:ansi_modifier/ansi_modifier.dart';
import '../extension/histogram.dart';
import '../extension/precision.dart';
import '../extension/duration_formatter.dart';
import '../extension/color_profile.dart';
import '../base/score.dart';

const plusMinus = '\u00B1';

/// Implement this interface to create a custom score emitter.
abstract interface class ScoreEmitter {
  void emit({required String description, required Score score});
}

/// Emits the mean of the benchmark scores.
/// The output generated is similar to the output generated by the
/// `PrintEmitter` of `benchmark_harness`.
class MeanEmitter implements ScoreEmitter {
  const MeanEmitter();

  /// Prints a colorized benchmark score.
  @override
  void emit({required String description, required Score score}) {
    print('$description(RunTime): ' +
        '${score.stats.mean.toStringAsFixedDigits()} us'
            .style(ColorProfile.mean) +
        '\n');
  }
}

/// Emits the benchmark duration, the score mean, score median,
/// and a score histogram.
class StatsEmitter implements ScoreEmitter {
  const StatsEmitter();

  /// Prints a colorized benchmark score report.
  @override
  void emit({
    required String description,
    required Score score,
  }) {
    //final indentCharacters = score.runtime.msus.length;
    final indent = '  ';
    final part1 = '${score.duration.msus.style(ColorProfile.dim)} $description';

    final mean = score.stats.mean / score.timeScale.factor;
    final stdDev = score.stats.stdDev / score.timeScale.factor;
    final median = score.stats.median / score.timeScale.factor;
    final iqr = score.stats.iqr / score.timeScale.factor;
    final unit = score.timeScale.unit;

    final part2 = '${indent}mean: ${mean.toStringAsFixedDigits()} $plusMinus '
                '${stdDev.toStringAsFixedDigits()} $unit, '
            .style(ColorProfile.mean) +
        'median: ${median.toStringAsFixedDigits()} $plusMinus '
                '${iqr.toStringAsFixedDigits()} $unit'
            .style(ColorProfile.median);

    final part3 = '$indent${score.stats.blockHistogram()} '
        'sample size: ${score.stats.sortedSample.length}';
    final part4 =
        score.innerIter > 1 ? ' (averaged over ${score.innerIter} runs)' : '';
    print(part1);
    print(part2);
    print(part3 + part4.style(ColorProfile.dim));
    print('');
  }
}
